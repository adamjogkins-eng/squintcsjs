<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PRISM V3 + SQUINT GUIDE</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent: #00f2ff;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
            --bg: #050508;
        }
        
        /* STRICT MOBILE & ZOOM FIXES */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            box-sizing: border-box;
            touch-action: manipulation; 
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--bg); 
            font-family: 'Space Grotesk', sans-serif; 
            color: white; 
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        
        canvas { 
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%; 
            display: block; 
            z-index: 1; /* Keep game behind UI */
        }
        
        #ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px); 
            left: 20px;
            background: var(--glass);
            padding: 12px 18px;
            border-radius: 15px;
            pointer-events: none;
            border: 1px solid var(--border);
            backdrop-filter: blur(20px);
            z-index: 100;
        }

        .device-tag {
            font-size: 0.6rem;
            background: var(--accent);
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
            margin-bottom: 5px;
            display: inline-block;
        }

        #top-actions {
            position: absolute;
            top: env(safe-area-inset-top, 20px); 
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 200;
        }

        .action-btn {
            width: 44px; height: 44px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 50%;
            color: white;
            display: flex; align-items: center; justify-content: center;
            font-weight: 500; cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            pointer-events: auto;
        }
        .action-btn:active { transform: scale(0.9); background: var(--accent); color: #000; }

        #tutorial-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.98);
            z-index: 1000;
            display: none;
            overflow-y: auto;
            padding: 20px;
            backdrop-filter: blur(20px);
            -webkit-user-select: text;
            user-select: text;
        }

        .tutorial-content {
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
            padding-bottom: 80px;
        }

        .copy-block {
            position: relative;
            margin: 20px 0;
        }

        .copy-btn {
            position: absolute;
            top: 10px; right: 10px;
            background: var(--accent);
            color: black;
            border: none;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            z-index: 5;
        }

        pre { 
            background: #000; padding: 20px; border-radius: 12px; border: 1px solid var(--border); 
            overflow-x: auto; color: #ddd; -webkit-user-select: all; user-select: all; 
            font-size: 0.85rem; white-space: pre-wrap; word-break: break-all;
            margin: 0;
        }
        
        #gameover {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 5, 5, 0.98);
            padding: 30px;
            width: 85%;
            max-width: 300px;
            border-radius: 32px;
            text-align: center;
            display: none;
            border: 1px solid #ff4444;
            z-index: 500;
            backdrop-filter: blur(20px);
        }

        .brand { font-weight: 700; font-size: 0.7rem; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .score-val { font-size: 2rem; font-weight: 700; display: block; text-shadow: 0 0 20px var(--accent); }
        
        /* BUTTON VISIBILITY FIXES */
        #controls {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px); 
            left: 0; width: 100%;
            display: flex; justify-content: space-between;
            padding: 0 30px; 
            box-sizing: border-box;
            pointer-events: none; /* Container is passthrough */
            z-index: 150; /* Above canvas */
        }

        .ctrl-btn {
            width: 85px; height: 85px;
            background: rgba(255, 255, 255, 0.12);
            border: 2px solid var(--border);
            border-radius: 24px;
            pointer-events: auto; /* Buttons are clickable */
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 32px;
            backdrop-filter: blur(15px);
            touch-action: none;
            transition: transform 0.1s, background 0.1s;
        }
        /* Visual feedback for touch/click */
        .ctrl-btn.active, .ctrl-btn:active { 
            background: var(--accent); 
            color: #000; 
            border-color: var(--accent);
            transform: scale(0.92);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
        }

        .pc-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 0.7rem;
            opacity: 0.5;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 100;
        }
        
        .primary-btn {
            background: var(--accent); color: #000;
            border: none; padding: 16px;
            border-radius: 50px; font-family: inherit;
            font-weight: 700; cursor: pointer;
            width: 100%; margin-top: 15px;
        }

        .contact-box {
            margin-top: 30px;
            padding: 20px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 12px;
            border-left: 4px solid var(--accent);
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="device-info" class="device-tag">DETECTING...</div><br>
        <span class="brand">SQUINT ENGINE</span><br>
        <span id="score" class="score-val">0</span>
    </div>

    <div id="top-actions">
        <div class="action-btn" id="btnReset" title="Reset">R</div>
        <div class="action-btn" id="btnTutorial" title="Guide">?</div>
    </div>

    <div id="tutorial-overlay">
        <div class="tutorial-content">
            <button class="primary-btn" style="width: auto; padding: 12px 24px;" onclick="toggleTutorial()">CLOSE GUIDE</button>
            <h1 style="color:var(--accent); margin-top: 25px;">Mission: Universal Squint Adoption</h1>
            <p>You're building the foundation. When AIs start writing Squint by default, it'll be because of code like this.</p>
            
            <h3>1. The CDN Entry Point</h3>
            <div class="copy-block">
                <button class="copy-btn" onclick="copyText('cdn-code')">COPY</button>
                <pre id="cdn-code">import { compileString } from 'https://unpkg.com/squint-cljs/index.js';
const CORE = 'https://unpkg.com/squint-cljs/core.js';</pre>
            </div>

            <h3>2. The Universal Template</h3>
            <div class="copy-block">
                <button class="copy-btn" onclick="copyText('template-code')">COPY</button>
                <pre id="template-code">&lt;script type="module"&gt;
  import { compileString } from 'https://unpkg.com/squint-cljs/index.js';
  
  const cljs = `
    (defn salute [target]
      (str "Future AI says: Hello, " target "!"))

    (js/console.log (salute "Architect"))
  `;

  try {
    const js = compileString(cljs, { 
      core_module: 'https://unpkg.com/squint-cljs/core.js' 
    });
    
    const script = document.createElement('script');
    script.type = 'module';
    script.textContent = js;
    document.body.appendChild(script);
    
  } catch (err) {
    console.error("Squint Error:", err);
  }
&lt;/script&gt;</pre>
            </div>

            <div class="contact-box">
                <h3 style="margin-top:0; color:var(--accent);">Support & Community</h3>
                <p>Youtube: <code style="user-select:all;">@squintcljs</code></p>
                <p>Email: <code style="user-select:all;">squintjs.com</code></p>
            </div>
        </div>
    </div>

    <div id="gameover">
        <h1 style="margin:0; color:#ff4444;">CRASHED</h1>
        <p>Altitude: <span id="finalScore">0</span>m</p>
        <button class="primary-btn" onclick="initGame()">REBOOT</button>
    </div>

    <div id="controls">
        <div class="ctrl-btn" id="leftBtn">←</div>
        <div class="ctrl-btn" id="rightBtn">→</div>
    </div>
    <div class="pc-hint" id="pcHint">USE ARROW KEYS OR A/D</div>

    <canvas id="gl"></canvas>

    <script>
        const canvas = document.getElementById('gl');
        const gl = canvas.getContext('webgl2');

        const keys = { left: false, right: false };
        let state = {
            score: 0, camY: 0, posX: 0, posY: 5, velY: 0,
            lastY: 0, playing: true,
            platforms: [], stars: []
        };

        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        document.getElementById('device-info').innerText = isMobile ? 'MOBILE MODE' : 'PC MODE';
        
        if (!isMobile) {
            document.getElementById('controls').style.opacity = '0.4';
        } else {
            document.getElementById('pcHint').style.display = 'none';
        }

        // STRICT SAFARI ZOOM PREVENTION
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) e.preventDefault();
        }, { passive: false });

        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
        }, false);

        function copyText(id) {
            const text = document.getElementById(id).innerText;
            const el = document.createElement('textarea');
            el.value = text;
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            const btn = event.target;
            btn.innerText = "COPIED!";
            setTimeout(() => btn.innerText = "COPY", 2000);
        }

        const updateInputUI = () => {
            document.getElementById('leftBtn').classList.toggle('active', keys.left);
            document.getElementById('rightBtn').classList.toggle('active', keys.right);
        };

        // KEYBOARD
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            updateInputUI();
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
            updateInputUI();
        });

        // BUTTONS - Pointer Events work for both Mouse and Touch
        const setupBtn = (id, key) => {
            const el = document.getElementById(id);
            const start = (e) => { 
                e.preventDefault(); 
                keys[key] = true; 
                updateInputUI(); 
            };
            const stop = (e) => { 
                e.preventDefault(); 
                keys[key] = false; 
                updateInputUI(); 
            };
            
            el.addEventListener('pointerdown', start);
            el.addEventListener('pointerup', stop);
            el.addEventListener('pointerleave', stop);
            el.addEventListener('pointercancel', stop);
        };
        
        setupBtn('leftBtn', 'left');
        setupBtn('rightBtn', 'right');

        // WEBGL ENGINE
        const SHADERS = {
            vs: `#version 300 es
                in vec4 a_pos; in vec4 a_col;
                uniform mat4 u_mat;
                out vec4 v_col;
                void main() { gl_Position = u_mat * a_pos; v_col = a_col; }`,
            fs: `#version 300 es
                precision highp float;
                in vec4 v_col; out vec4 color;
                void main() { color = v_col; }`
        };

        function createProgram(gl, vs, fs) {
            const p = gl.createProgram();
            [vs, fs].forEach((src, i) => {
                const s = gl.createShader(i ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER);
                gl.shaderSource(s, src); gl.compileShader(s); gl.attachShader(p, s);
            });
            gl.linkProgram(p); return p;
        }

        const prog = createProgram(gl, SHADERS.vs, SHADERS.fs);
        const locs = { pos: gl.getAttribLocation(prog, "a_pos"), col: gl.getAttribLocation(prog, "a_col"), mat: gl.getUniformLocation(prog, "u_mat") };
        const cubePos = new Float32Array([-1,-1,1, 1,-1,1, 1,1,1, -1,1,1, -1,-1,-1, -1,1,-1, 1,1,-1, 1,-1,-1, -1,1,-1, -1,1,1, 1,1,1, 1,1,-1, -1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1, 1,-1,-1, 1,1,-1, 1,1,1, 1,-1,1, -1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1]);
        const cubeIdx = new Uint16Array([0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23]);
        const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, cubePos, gl.STATIC_DRAW);
        const idxBuf = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIdx, gl.STATIC_DRAW);

        function createColorBuffer(rgba) {
            const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(Array(24).fill(rgba).flat()), gl.STATIC_DRAW);
            return buf;
        }

        const colors = {
            player: createColorBuffer([1, 1, 1, 1]),
            normal: createColorBuffer([0.2, 0.4, 1.0, 1]),
            boost: createColorBuffer([0, 0.95, 1.0, 1]),
            shatter: createColorBuffer([1, 0.2, 0.2, 1]),
            star: createColorBuffer([0.2, 0.2, 0.3, 1])
        };

        function spawnPlatform(y, isStart = false) {
            const typeRoll = Math.random();
            const type = isStart ? 'normal' : (typeRoll > 0.9 ? 'boost' : (typeRoll > 0.75 ? 'shatter' : 'normal'));
            state.platforms.push({ x: isStart ? 0 : (Math.random() - 0.5) * 18, y: y, w: isStart ? 10 : 2 + Math.random() * 2, type: type, buf: colors[type] });
        }

        function initGame() {
            state.score = 0; state.camY = 0; state.posX = 0; state.posY = 5; state.velY = 0;
            state.lastY = 0; state.playing = true; state.platforms = []; state.stars = [];
            for(let i=0; i<60; i++) state.stars.push({x: (Math.random()-0.5)*100, y: Math.random()*200, z: -30});
            for(let i=0; i<15; i++) { state.lastY = i * 6; spawnPlatform(state.lastY, i===0); }
            document.getElementById('gameover').style.display = 'none';
            document.getElementById('score').innerText = "0";
        }

        function toggleTutorial() {
            const over = document.getElementById('tutorial-overlay');
            over.style.display = over.style.display === 'block' ? 'none' : 'block';
        }

        document.getElementById('btnReset').onclick = () => initGame();
        document.getElementById('btnTutorial').onclick = () => toggleTutorial();

        const m4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            mul: (a, b) => {
                const out = new Float32Array(16);
                for(let i=0; i<4; i++) for(let j=0; j<4; j++) out[j*4+i] = a[i]*b[j*4] + a[i+4]*b[j*4+1] + a[i+8]*b[j*4+2] + a[i+12]*b[j*4+3];
                return out;
            },
            perspective: (fov, aspect, near, far) => {
                const f = 1.0 / Math.tan(fov / 2), nf = 1 / (near - far), out = m4.identity();
                out[0] = f / aspect; out[5] = f; out[10] = (far + near) * nf; out[11] = -1; out[14] = (2 * far * near) * nf; out[15] = 0;
                return out;
            },
            translate: (x, y, z) => { const out = m4.identity(); out[12]=x; out[13]=y; out[14]=z; return out; },
            scale: (x, y, z) => { const out = m4.identity(); out[0]=x; out[5]=y; out[10]=z; return out; }
        };

        function draw(mat, buf, pos, size) {
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.vertexAttribPointer(locs.pos, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(locs.pos);
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.vertexAttribPointer(locs.col, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(locs.col);
            const model = m4.mul(m4.translate(pos[0], pos[1], pos[2]), m4.scale(size[0], size[1], size[2]));
            gl.uniformMatrix4fv(locs.mat, false, m4.mul(mat, model));
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        }

        function loop() {
            if (state.playing) {
                state.velY -= 0.015;
                state.posY += state.velY;
                
                let moveDir = 0;
                if (keys.left) moveDir -= 1;
                if (keys.right) moveDir += 1;
                state.posX += moveDir * 0.28;

                if(Math.abs(state.posX) > 20) state.posX *= -0.9;
                if(state.velY < 0) {
                    state.platforms.forEach((p, i) => {
                        if(state.posY > p.y && state.posY < p.y + 1.2 && Math.abs(state.posX - p.x) < p.w + 0.5) {
                            state.velY = p.type === 'boost' ? 0.75 : 0.45;
                            state.posY = p.y + 0.5;
                            if(p.y > state.score) { state.score = Math.floor(p.y); document.getElementById('score').innerText = state.score; }
                            if(p.type === 'shatter') state.platforms.splice(i, 1);
                        }
                    });
                }
                if(state.posY > state.lastY - 50) { state.lastY += 6; spawnPlatform(state.lastY); }
                state.camY += (state.posY - state.camY) * 0.1;
                if(state.posY < state.camY - 25) { 
                    state.playing = false; 
                    document.getElementById('gameover').style.display = 'block';
                    document.getElementById('finalScore').innerText = state.score;
                }
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0.02, 0.02, 0.04, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);
                const view = m4.mul(m4.perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1000), m4.translate(0, -state.camY, -40));
                gl.useProgram(prog);
                state.stars.forEach(s => draw(view, colors.star, [s.x, s.y + (state.camY*0.5), s.z], [0.1, 0.1, 0.1]));
                state.platforms.forEach(p => draw(view, p.buf, [p.x, p.y, 0], [p.w, 0.2, 2]));
                draw(view, colors.player, [state.posX, state.posY, 0], [0.6, 0.6, 0.6]);
            }
            requestAnimationFrame(loop);
        }

        initGame();
        loop();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>

